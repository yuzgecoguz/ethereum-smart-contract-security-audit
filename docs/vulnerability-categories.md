# Vulnerability Categories

## 1. Reentrancy

### Description
A reentrancy attack exploits the ability of a malicious contract to recursively call back into the victim contract before the first invocation is complete. This allows the attacker to repeatedly drain funds by calling the withdrawal function before the balance is updated.

### Pattern
```
1. Victim contract sends ETH via external call
2. Attacker's fallback/receive function triggers
3. Attacker re-enters the victim's withdraw function
4. Balance hasn't been updated yet → withdrawal succeeds again
5. Repeat until drained
```

### Vulnerable Code Pattern
```solidity
function withdraw() public {
    uint256 amount = balances[msg.sender];
    (bool success, ) = msg.sender.call{value: amount}(""); // External call FIRST
    balances[msg.sender] = 0; // State update SECOND — too late
}
```

### Secure Code Pattern
```solidity
function withdraw() public nonReentrant {
    uint256 amount = balances[msg.sender];
    balances[msg.sender] = 0; // State update FIRST
    (bool success, ) = msg.sender.call{value: amount}(""); // External call SECOND
    require(success);
}
```

### Mitigation
- **Checks-Effects-Interactions pattern**: Update state before making external calls
- **ReentrancyGuard**: Use OpenZeppelin's `nonReentrant` modifier
- **Pull-over-push**: Let users withdraw rather than pushing funds to them

---

## 2. Access Control

### Description
Access control vulnerabilities occur when contract functions lack proper authorization checks, allowing unauthorized users to execute privileged operations such as fund transfers, ownership changes, or contract self-destruction.

### Common Patterns

**tx.origin misuse**:
```solidity
// VULNERABLE: tx.origin can be spoofed through contract chains
require(tx.origin == owner);

// SECURE: msg.sender is the direct caller
require(msg.sender == owner);
```

**Missing access control**:
```solidity
// VULNERABLE: Anyone can call this critical function
function updatePrice(uint256 newPrice) public {
    price = newPrice;
}

// SECURE: Only owner can update
function updatePrice(uint256 newPrice) public onlyOwner {
    price = newPrice;
}
```

### Mitigation
- Use `msg.sender` instead of `tx.origin` for authentication
- Implement role-based access control (OpenZeppelin AccessControl)
- Use the `Ownable` pattern for simple owner-only functions
- Apply the principle of least privilege

---

## 3. Price Oracle Manipulation

### Description
Price oracle manipulation exploits occur when a DeFi protocol uses a price feed that can be temporarily manipulated. The most common attack vector involves flash loans to move prices in shallow-liquidity AMMs that serve as price oracles for lending protocols.

### Attack Flow
```
┌─────────────────┐
│  1. Flash Loan   │ Borrow large amount (e.g., 2 ETH)
│     2 ETH        │
└────────┬────────┘
         │
┌────────▼────────┐
│  2. Swap in AMM  │ Swap 2 ETH → USDC in shallow pool
│  ETH → USDC      │ Price impact: USDC/ETH price 9x inflated
└────────┬────────┘
         │
┌────────▼────────┐
│  3. Deposit       │ Deposit USDC as collateral in lending protocol
│  USDC Collateral  │ Protocol reads inflated AMM price
└────────┬────────┘
         │
┌────────▼────────┐
│  4. Overborrow   │ Borrow 4.8 ETH (should only get ~0.8 ETH)
│  4.8 ETH         │ at manipulated collateral valuation
└────────┬────────┘
         │
┌────────▼────────┐
│  5. Repay Loan   │ Repay 2 ETH flash loan
│  Keep 2.8 ETH    │ Net profit: 2.8 ETH
└─────────────────┘
```

### Mitigation
- **TWAP oracles**: Use Time-Weighted Average Prices instead of spot prices
- **Chainlink price feeds**: Decentralized oracle networks resistant to single-pool manipulation
- **Minimum liquidity thresholds**: Reject price feeds from low-liquidity pools
- **Price deviation circuit breakers**: Pause operations if price deviates beyond threshold
- **Multi-source price aggregation**: Combine multiple independent price sources
