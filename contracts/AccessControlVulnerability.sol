// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title AccessControlVulnerability
 * @author Oguzhan Yuzgec
 * @notice Demonstrates the tx.origin authentication vulnerability
 * @dev Using tx.origin for authorization allows phishing attacks where a malicious
 *      contract tricks the owner into calling it, inheriting the owner's tx.origin.
 *
 * Attack vector:
 *   1. Owner interacts with a malicious contract (e.g., "claim free tokens")
 *   2. Malicious contract calls MyContract.sendTo(attackerAddress, contractBalance)
 *   3. tx.origin == owner (because the owner initiated the transaction chain)
 *   4. Funds are sent to the attacker
 *
 * Mitigation:
 *   - Always use msg.sender instead of tx.origin for authorization
 *   - Use OpenZeppelin's Ownable or AccessControl contracts
 *
 * @custom:source https://consensys.github.io/smart-contract-best-practices/
 */
contract AccessControlVulnerable {
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    /// @notice VULNERABLE: Uses tx.origin instead of msg.sender
    function sendTo(address payable receiver, uint256 amount) public {
        // tx.origin returns the original externally-owned account (EOA) that
        // initiated the transaction chain, NOT the immediate caller
        require(tx.origin == owner, "Not authorized");
        receiver.transfer(amount);
    }

    receive() external payable {}
}
